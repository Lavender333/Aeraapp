Despite critical issues that need addressing, AERA demonstrates several well-implemented patterns and architectural decisions that provide a solid
foundation for improvement.
1. Clean Component Architecture
Separation of Concerns
Why this works: New developers can quickly understand where code belongs. Each layer has clear responsibility.
View State Management
2. TypeScript Throughout Frontend
Strong typing provides compile-time safety:
IDE autocomplete and error detection
Self-documenting code
Catch bugs at compile time
!"" views/           # 17 page-level components
!"" components/      # Reusable UI primitives
!"" services/        # Business logic layer
#   !"" storage.ts   # LocalStorage + API orchestration
#   !"" api.ts       # REST client
#   $"" translations.ts
!"" models/          # Mongoose schemas
$"" types.ts         # Centralized type definitions
| 'SPLASH' | 'LOGIN' | 'REGISTRATION'
| 'DASHBOARD' | 'HELP_WIZARD' | 'ORG_DASHBOARD'
| 'SETTINGS' | 'MAP' | 'ALERTS' | 'ASSESSMENT'
| 'GAP' | 'PRESENTATION' | 'ORG_REGISTRATION';
// Clean navigation pattern
const [currentView, setCurrentView] = useState<ViewState>('SPLASH');
communityId?: string;
// ... 15+ typed fields
| 'ADMIN' | 'CONTRACTOR' | 'LOCAL_AUTHORITY'
3. Offline-First Design
Critical for Emergency Response
The app works without internet - essential during disasters:
LocalStorage as Primary Store
4. Internationalization (i18n)
Three languages supported with fallback chain:
Impact: Accessible to diverse communities during emergencies.
5. Role-Based Access Control Structure
Well-defined roles with clear purposes:
Role Purpose Example User
ADMIN System administratorIT staff
INSTITUTION_ADMINOrganization managerPastor John
FIRST_RESPONDER Emergency personnelFirefighters
LOCAL_AUTHORITY Government officials FEMA coordinators
CONTRACTOR Service providers Relief workers
GENERAL_USER Citizens Community members
6. Comprehensive Domain Modeling
Emergency Help Request
// services/storage.ts - Sync flag pattern
synced: navigator.onLine  // Track sync status
// Graceful degradation
async fetchOrgInventoryRemote(orgId: string) {
console.warn('API fetch failed, using local data');
getDB(): BackendDB {
const raw = localStorage.getItem(DB_KEY);
return raw ? JSON.parse(raw) : this.initializeDB();
return translations[currentLanguage]?.[key]
|| translations['en'][key]
The 5-step wizard captures all necessary triage information:
Intelligent Priority Calculation
7. RESTful API Design
Clean, predictable URL patterns:
// Step 1: Safety Assessment
emergencyType: EmergencyType;
// Step 2: Situation Details
// Step 3: Resource Status
// Step 4: Vulnerability Assessment
needsTransportAssistance: boolean;
vulnerableGroups: VulnerableGroup[];
damageType: DamageType;
// Automatic triage based on data
calculatePriority(data: HelpRequestData): Priority {
if (!data.canEvacuate ||
data.vulnerableGroups.length > 0 ||
data.emergencyType === 'Flood') return 'HIGH';
8. AI Integration for Emergency Assistance
Gemini-Powered Features
MapView: AI resource finder for shelters, supplies
AlertsView: Emergency Q&A assistant
AssessmentView: Damage assessment from photos
9. Multi-Platform Deployment Ready
Netlify Configuration
Render Configuration
GitHub Actions CI/CD
10. Event-Driven Updates
Cross-component communication without prop drilling:
{ upsert: true }  // Create if not exists
// services/mockGenAI.ts
generateContent(prompt: string): Promise<MockResponse> {
// Simulated responses for development without API key
command = "npm run build"
# .github/workflows/deploy.yml
// Listen for updates
const handler = () => refreshInventory();
Strength Business Impact
Clean architectureMaintainability, onboarding
TypeScript Code quality, fewer bugs
Offline-first Works during disasters
i18n support Serves diverse communities
RBAC structure Security foundation
Domain modeling Correct business logic
RESTful API Developer experience
AI integration User assistance
Multi-deploy Operational flexibility
These foundations provide a solid base. The issues identified are addressable without architectural rewrites.
window.addEventListener('inventory-update', handler);
return () => window.removeEventListener('inventory-update', handler);
This document identifies critical issues, bugs, and architectural problems requiring immediate attention before production deployment.
CRITICAL ISSUES (P0)
1. Authentication Middleware Defined But Never Applied
Location: server.js:45-55
The auth middleware function exists but is never used on any route:
All organization data publicly accessible
Anyone can modify any organization's members, inventory, requests
PII (personal information) exposed without authentication
Complete security model bypassed
2. No Organization Model in Backend
Location: models/ directory (missing)
Organizations only exist in frontend localStorage:
// Middleware IS defined...
if (!header) return res.status(401).json({ error: 'missing auth' });
const decoded = jwt.verify(token, JWT_SECRET);
return res.status(401).json({ error: 'invalid auth' });
// But NEVER APPLIED to routes!
app.get('/api/orgs/:orgId/inventory', async (req, res) => {
// NO AUTH - Anyone can read any org's inventory!
app.post('/api/orgs/:orgId/members', async (req, res) => {
// NO AUTH - Anyone can add members to any org!
app.delete('/api/orgs/:orgId/members/:id', async (req, res) => {
// NO AUTH - Anyone can delete any member!
// Apply to all protected routes
app.get('/api/orgs/:orgId/inventory', auth, async (req, res) => { ... });
app.post('/api/orgs/:orgId/members', auth, async (req, res) => { ... });
// Frontend has full Organization handling
Organization data not persisted to database
Multi-user/device sync impossible
Clear browser = lose all org data
No single source of truth
Backend routes use orgId that doesn't validate against anything
3. Hardcoded JWT Secret Fallback
Location: server.js:38
If JWT_SECRET env var not set in production, uses known value
Attackers can forge valid JWT tokens with 'dev-secret'
Complete authentication bypass
4. Password Reset Token Exposed in API Response
Location: server.js:86-97
Anyone can request password reset for any email
Token returned immediately (no email verification)
Direct account takeover vulnerability
// Backend models directory:
!"" broadcast.js       ✓
!"" helpRequest.js     ✓
!"" inventory.js       ✓
!"" member.js          ✓
!"" memberStatus.js    ✓
!"" request.js         ✓
!"" user.js            ✓
#"" organization.js    ✗ MISSING!
const JWT_SECRET = process.env.JWT_SECRET || 'dev-secret';
//                                           ^^^^^^^^^^^^
//                                           HARDCODED FALLBACK
console.error('FATAL: JWT_SECRET environment variable required');
app.post('/api/auth/forgot', async (req, res) => {
const { email } = req.body || {};
if (!user) return res.json({ ok: true }); // Good: doesn't leak existence
const token = Math.random().toString(36).slice(2, 8).toUpperCase();
user.resetToken = token;
user.resetTokenExpiresAt = new Date(Date.now() + 15 * 60 * 1000);
// PROBLEM: Token returned directly in response!
res.json({ ok: true, resetToken: token });
Fix: Send token via email only, never in API response:
5. No Input Validation or Sanitization
Location: All API routes
User input used directly without validation:
NoSQL injection via $  operators: { "$gt": "" }
Type coercion attacks
Negative quantity values
XSS payloads stored in database
HIGH SEVERITY ISSUES (P1)
Location: server.js (missing)
No protection against brute force or DoS:
Brute force password attacks
Account enumeration via timing
Password reset flooding
API abuse / denial of service
7. Weak Reset Token Generation
Location: server.js:91
res.json({ ok: true, message: 'If account exists, reset email sent' });
// Actually send email with token
app.post('/api/orgs/:orgId/requests', async (req, res) => {
const { item, quantity, provider, orgName } = req.body || {};
// Only checks existence, not type/format
if (!item || !quantity) return res.status(400).json({ error: '...' });
// Directly used in database - no sanitization!
orgId,      // From URL - could be injection payload
orgName,    // From body - no validation
item,       // From body - no validation
quantity,   // Could be negative, string, object with $operators
provider,   // No validation
// No rate limiting on sensitive endpoints
app.post('/api/auth/register', async (req, res) => { ... });
app.post('/api/auth/login', async (req, res) => { ... });
app.post('/api/auth/forgot', async (req, res) => { ... });
// Results in: 6 alphanumeric characters (e.g., "ABC123")
// Entropy: 36^6 ≈ 2.17 billion combinations
// At 1000 attempts/second: ~25 days to exhaust
// With no rate limiting: minutes to hours
Fix: Use cryptographically secure tokens:
8. Duplicate/Conflicting Status Models
Location: models/member.js and models/memberStatus.js
Two collections track the same information:
Which is source of truth?
Updates to one don't propagate to other
Data inconsistency guaranteed
Confusion for developers
9. No Pagination on List Endpoints
Location: All GET list routes
Mobile data consumption
10. Frontend-Backend Type Mismatch
Location: types.ts vs models/request.js
// models/member.js - Full member profile
const memberSchema = {
status: { enum: ['SAFE', 'DANGER', 'UNKNOWN'] },  // Status here
// models/memberStatus.js - Just status
const memberStatusSchema = {
status: { enum: ['SAFE', 'DANGER', 'UNKNOWN'] },  // Status ALSO here
app.get('/api/orgs/:orgId/members', async (req, res) => {
const docs = await Member.find({ orgId }).lean();
res.json(docs);  // Returns ALL - could be 10,000+ records
// Frontend types.ts
signature?: string;           // Field exists
signedAt?: string;            // Field exists
receivedSignature?: string;   // Field exists
receivedAt?: string;          // Field exists
stocked?: boolean;            // Field exists
MEDIUM SEVERITY ISSUES (P2)
11. Inconsistent Error Handling
12. No Request Logging
13. No Database Connection Error Handling
14. No Test Coverage
15. CORS Falls Back to Allow All
LOW SEVERITY ISSUES (P3)
// Backend models/request.js
const requestSchema = {
status: { enum: ['PENDING', 'FULFILLED', 'STOCKED'] }, // Missing 'APPROVED'!
// Missing: signature, signedAt, receivedSignature, receivedAt, stocked
deliveredQuantity: Number,  // Frontend doesn't have this!
// Different formats used
res.status(400).json({ error: 'item and quantity required' });
// No consistent schema:
// - No field-level errors
// - No stack traces in dev
// No logging middleware
// - Who accessed what data
// - Failed auth attempts
// - Performance issues
// - Security incidents
await mongoose.connect(mongoUri, { dbName: process.env.MONGODB_DB });
// No reconnection logic
// No health monitoring
// Server crashes on DB failure
tests/           # Directory doesn't exist
*.test.ts        # No test files
*.spec.ts        # No spec files
jest.config.*    # No test config
process.env.FRONTEND_ORIGIN,  // Could be undefined
origin: allowedOrigins.length ? allowedOrigins : '*'  // Falls back to *
16. Console.log in Production Code
Multiple debug statements left in:
17. Duplicate Model Files
18. No API Versioning
19. Magic Strings for Item Matching
Should use constants/enum mapping.
20. No Graceful Shutdown
# Issue Severity Effort Priority
1 Auth middleware not appliedCRITICAL Low P0
2 No Organization model CRITICAL Medium P0
3 Hardcoded JWT secret CRITICAL Low P0
4 Reset token exposed CRITICAL Low P0
5 No input validation CRITICAL Medium P0
6 No rate limiting HIGH Low P1
7 Weak reset tokens HIGH Low P1
8 Duplicate status models HIGH Medium P1
9 No pagination HIGH Low P1
10 Type mismatches HIGH Medium P1
11 Inconsistent errors MEDIUM Medium P2
12 No logging MEDIUM Low P2
models/inventory.js   # JavaScript version
models/inventory.ts   # TypeScript version (identical content)
app.get('/api/orgs/:orgId/inventory', ...);
app.get('/api/v1/orgs/:orgId/inventory', ...);
if (doc.item.toLowerCase().includes('water')) inc.water = deliveredQuantity;
else if (doc.item.toLowerCase().includes('food')) inc.food = deliveredQuantity;
else if (doc.item.toLowerCase().includes('blanket')) inc.blankets = deliveredQuantity;
else if (doc.item.toLowerCase().includes('med')) inc.medicalKits = deliveredQuantity;
app.listen(port, () => console.log(`Listening on ${port}`));
// No SIGTERM/SIGINT handlers
// No connection draining
13 No DB error handling MEDIUM Low P2
14 No tests MEDIUM High P2
15 CORS permissive MEDIUM Low P2
16 Console.log statements LOW Low P3
17 Duplicate model files LOW Low P3
18 No API versioning LOW Low P3
19 Magic strings LOW Low P3
20 No graceful shutdown LOW Low P3
Database Layer Analysis
Database: MongoDB Atlas (cloud-hosted)
Connection: mongoose.connect() with connection string
Current Collections (7)
Collection Primary Key Indexes Documents/Org
users _id email (unique, sparse), phone (sparse), orgId~5-50
members _id orgId ~50-5000
memberstatuses _id orgId, (orgId+memberId unique) ~50-5000
inventories _id orgId (unique) 1
requests _id orgId ~10-100
helprequests _id orgId, userId ~10-1000
broadcasts _id orgId (unique) 1
Collection Status Impact
MISSING All org data in localStorage only
orgId references non-existent Organization collection
No validation that orgId exists
Email OR phone required but enforced at route level, not schema
role: { enum: ['ADMIN', 'CONTRACTOR', 'LOCAL_AUTHORITY',
'FIRST_RESPONDER', 'GENERAL_USER', 'INSTITUTION_ADMIN'] },
orgId: { type: String, index: true },  // Soft FK - no validation
fullName: { type: String },
status duplicated in MemberStatus collection
lastUpdate should be Date type, not String
No compound index for common query patterns
MemberStatus Schema (Redundant?)
Duplicates Member.status functionality
memberId doesn't validate against Member collection
Unclear which is source of truth
No validation for negative values
Fixed schema - can't add new item types easily
No history/audit trail
Request Schema (Replenishment)
Frontend expects APPROVED status - not in schema
Frontend expects signature, signedAt, etc. - not in schema
status: { enum: ['SAFE', 'DANGER', 'UNKNOWN'], default: 'UNKNOWN' },
location: { type: String },
lastUpdate: { type: String },  // Should be Date
needs: { type: [String] },
phone: { type: String },
address: { type: String },
emergencyContactName: { type: String },
emergencyContactPhone: { type: String },
emergencyContactRelation: { type: String },
status: { enum: ['SAFE', 'DANGER', 'UNKNOWN'] },
// Compound unique index: { orgId: 1, memberId: 1 }
water: { type: Number, default: 0 },      // cases
food: { type: Number, default: 0 },       // boxes
blankets: { type: Number, default: 0 },   // count
medicalKits: { type: Number, default: 0 }, // count
orgName: { type: String },  // Denormalized - could get stale
status: { enum: ['PENDING', 'FULFILLED', 'STOCKED'] },
No validation for negative quantity
orgName denormalization without update mechanism
data is schemaless Object - no validation
userId doesn't validate against User collection
No index on status for filtering active requests
No message length limit
No history of past broadcasts
1. No Organization Collection
Cannot validate orgId references
Multi-user sync impossible
Data lost on browser clear
No organization management API
orgId: { type: String, index: true },      // Optional org link
data: { type: Object, default: {} },       // Schemaless - dangerous
status: { enum: ['PENDING', 'RECEIVED', 'DISPATCHED', 'RESOLVED'] },
priority: { enum: ['LOW', 'MEDIUM', 'HIGH', 'CRITICAL'] },
Backend: Has orgId references everywhere but no Organization model
Frontend: Organizations exist only in localStorage
const organizationSchema = new mongoose.Schema({
type: { enum: ['CHURCH', 'NGO', 'COMMUNITY_CENTER', 'LOCAL_GOV'] },
adminContact: { type: String },
adminPhone: { type: String },
replenishmentProvider: { type: String },
replenishmentEmail: { type: String },
verified: { type: Boolean, default: false },
active: { type: Boolean, default: true },
allowPublicMembership: Boolean,
requireApproval: Boolean,
2. Soft Foreign Keys Without Validation
Option A: Application-Level Validation
Option B: Mongoose Refs (weaker but documented)
3. Duplicate Status Tracking
Recommendation: Eliminate MemberStatus, use Member only:
4. Schemaless HelpRequest.data
Solution: Define nested schema:
}, { timestamps: true });
// Member.orgId, User.orgId, etc. are just strings
// No validation that the orgId exists
// No cascade on delete
// No referential integrity
app.post('/api/orgs/:orgId/members', auth, async (req, res) => {
// Validate org exists
const org = await Organization.findById(req.params.orgId);
if (!org) return res.status(404).json({ error: 'Organization not found' });
const memberSchema = new mongoose.Schema({
type: mongoose.Schema.Types.ObjectId,
ref: 'Organization',
Member.status        - Full profile with status
MemberStatus.status  - Lightweight status only
// Remove models/memberStatus.js
db.memberstatuses.find().forEach(ms => {
db.members.updateOne(
{ _id: ms.memberId },
{ $set: { status: ms.status, statusUpdatedAt: ms.updatedAt } }
data: { type: Object, default: {} }  // Anything goes!1
const helpRequestDataSchema = new mongoose.Schema({
emergencyType: { enum: ['Medical', 'Fire', 'Flood', 'Structure', 'Other'] },
situationDescription: String,
canEvacuate: Boolean,
Recommended Schema Redesign
Entity Relationship Diagram
Current Indexes (Implicit + Defined)
Collection Index Type
users email unique, sparse
members orgId regular
memberstatusesorgId regular
memberstatusesorgId + memberIdcompound unique
hazardsPresent: Boolean,
const helpRequestSchema = new mongoose.Schema({
data: { type: helpRequestDataSchema, default: {} },
!"""""""""""""""""#       !"""""""""""""""""#
$  Organization   $       $      User       $
%"""""""""""""""""&       %"""""""""""""""""&
$ _id (ObjectId)  $◄""""""$ orgId (ref)     $
$ name            $       $ email           $
$ type            $       $ role            $
$ settings        $       $ passwordHash    $
'""""""""("""""""")       '""""""""""""""""")
$     Member      $       $   HelpRequest   $
$ orgId (ref)     $       $ orgId (ref)     $
$ userId (ref)?   $       $ userId (ref)    $
$ name            $       $ data (embedded) $
$ status          $       $ status          $
$ statusUpdatedAt $       $ priority        $
'""""""""""""""""")       '""""""""""""""""")
$   Inventory     $       $    Request      $
$ items: Map      $       $ item            $
$                 $       $ quantity        $
'""""""""""""""""")       $ status          $
▲                '""""""""""""""""")
inventories orgId unique
requests orgId regular
helprequests orgId regular
helprequests userId regular
broadcasts orgId unique
Recommended Additional Indexes
Phase 1: Add Organization Model (Week 1)
1. Create models/organization.js
2. Add migration script to seed from frontend data
3. Add CRUD API endpoints
4. Update frontend to use API instead of localStorage
Phase 2: Fix Type Mismatches (Week 2)
1. Add missing fields to Request schema
2. Add missing status enum values
3. Run migration to add defaults
Phase 3: Consolidate Status (Week 3)
1. Migrate MemberStatus data into Member
2. Add statusUpdatedAt to Member
3. Update all routes to use Member only
4. Delete MemberStatus collection
Phase 4: Schema Validation (Week 4)
1. Add nested schema for HelpRequest.data
2. Add min/max validators for quantities
3. Add string length limits
4. Run validation report on existing data
No backup strategy documented.
// Common query patterns need indexes
// Find active help requests by priority
helpRequestSchema.index({ status: 1, priority: 1 });
// Find pending requests by org
requestSchema.index({ orgId: 1, status: 1 });
// Find members needing status update
memberSchema.index({ orgId: 1, status: 1 });
// User lookup by org and role
userSchema.index({ orgId: 1, role: 1 });
// MongoDB Atlas automated backups
// - Enable continuous backup
// - Set retention: 7 days point-in-time, 30 days snapshots
// - Test restore procedure quarterly
// Application-level export
app.get('/api/admin/export/:orgId', adminAuth, async (req, res) => {
members: await Member.find({ orgId }),
inventory: await Inventory.findOne({ orgId }),
requests: await Request.find({ orgId }),
Security Layer Analysis
The AERA application has critical security vulnerabilities that would allow complete unauthorized access to all data. The security model is partially
designed but not implemented.
Security Score: 3/10
Category Score Status
Implemented, not enforced
Input Validation 1/10
Data Protection 5/10
Transport Security 6/10
Session Management5/10
VULN-001: Authentication Bypass (CVSS: 9.8 Critical)
Description: Auth middleware exists but is never applied to routes.
Location: server.js - all route definitions
VULN-002: Hardcoded Secret Fallback (CVSS: 9.1 Critical)
Description: JWT secret falls back to hardcoded value if env var missing.
# No auth required - anyone can access any org's data
curl https://api.example.com/api/orgs/CH-9921/inventory
# Returns: {"orgId":"CH-9921","water":120,"food":45,...}
curl -X POST https://api.example.com/api/orgs/CH-9921/members \
-d '{"name":"Attacker","phone":"555-0000"}'
# Returns: {"id":"...","name":"Attacker",...}  # Successfully added!
// Apply auth middleware to ALL protected routes
const protectedRoutes = express.Router();
protectedRoutes.use(auth);  // Apply to all routes in this router
protectedRoutes.get('/orgs/:orgId/inventory', async (req, res) => {...});
protectedRoutes.post('/orgs/:orgId/members', async (req, res) => {...});
// ... all other protected routes
app.use('/api', protectedRoutes);
// Keep auth routes public
app.post('/api/auth/register', ...);
app.post('/api/auth/login', ...);
const JWT_SECRET = process.env.JWT_SECRET || 'dev-secret';1
VULN-003: Password Reset Token Exposure (CVSS: 8.1 High)
Description: Reset token returned directly in API response.
VULN-004: NoSQL Injection (CVSS: 7.5 High)
// Attacker can forge valid tokens
const forgedToken = jwt.sign(
{ sub: 'admin-user-id', role: 'ADMIN', orgId: 'any-org' },
'dev-secret',  // Known fallback value
// Now has admin access to entire system
if (!JWT_SECRET || JWT_SECRET.length < 32) {
console.error('FATAL: JWT_SECRET must be set and at least 32 characters');
// ...generate token...
res.json({ ok: true, resetToken: token });  // Exposed!
# Request reset for victim
curl -X POST https://api.example.com/api/auth/forgot \
-d '{"email":"victim@example.com"}'
# Response: {"ok":true,"resetToken":"ABC123"}
# Use token to reset password
curl -X POST https://api.example.com/api/auth/reset \
-d '{"email":"victim@example.com","token":"ABC123","newPassword":"hacked"}'
# Account taken over!
// Always return same response (don't leak existence)
return res.json({ ok: true, message: 'If account exists, email sent' });
const hashedToken = crypto.createHash('sha256').update(token).digest('hex');
user.resetToken = hashedToken;  // Store hash, not token
// Send token via email ONLY
await sendEmail(email, `Reset link: https://app.com/reset?token=${token}`);
res.json({ ok: true, message: 'If account exists, email sent' });
Description: User input passed directly to database queries without sanitization.
VULN-005: Missing Rate Limiting (CVSS: 5.3 Medium)
Description: No rate limiting allows brute force attacks.
Location: All routes, especially auth endpoints
# NoSQL injection to bypass authentication
curl -X POST https://api.example.com/api/auth/login \
-d '{"email":{"$gt":""},"password":"anything"}'
# Matches first user in database!
// Global middleware
app.use(mongoSanitize());  // Strips $ and . from input
// Input validation with Zod
phone: z.string().regex(/^\+?[0-9]{10,15}$/).optional(),
password: z.string().min(1),
message: 'Email or phone required'
const result = loginSchema.safeParse(req.body);
return res.status(400).json({ error: result.error.issues });
const { email, phone, password } = result.data;
for password in $(cat wordlist.txt); do
-d "{\"email\":\"admin@example.com\",\"password\":\"$password\"}"
# No rate limiting = unlimited attempts
// Strict limit for auth endpoints
max: 5,  // 5 attempts per window
message: { error: 'Too many attempts, try again later' },
Authorization Issues
AUTHZ-001: No Resource-Level Authorization
Problem: Even with auth, users can access any organization's data.
Current (with auth applied):
AUTHZ-002: No Role-Based Restrictions
Problem: Role field exists but not enforced.
app.post('/api/auth/login', authLimiter, async (req, res) => {...});
app.post('/api/auth/forgot', authLimiter, async (req, res) => {...});
// General API limit
windowMs: 60 * 1000,  // 1 minute
max: 100,  // 100 requests per minute
app.use('/api/', apiLimiter);
app.get('/api/orgs/:orgId/members', auth, async (req, res) => {
const members = await Member.find({ orgId: req.params.orgId });
res.json(members);  // Returns data even if user not in this org!
// Authorization middleware
const belongsToOrg = async (req, res, next) => {
const { sub: userId, role, orgId: userOrgId } = req.user;
// Admins can access any org
if (role === 'ADMIN') return next();
// Users can only access their own org
if (userOrgId !== orgId) {
app.get('/api/orgs/:orgId/members', auth, belongsToOrg, async (req, res) => {...});
// Anyone can delete members
const requireRole = (...roles) => (req, res, next) => {
if (!roles.includes(req.user.role)) {
// Only org admins can delete members
app.delete('/api/orgs/:orgId/members/:id',
requireRole('ADMIN', 'INSTITUTION_ADMIN'),
async (req, res) => {...}
Current Password Handling
Problem: API returns all user data including sensitive fields.
Recommended Security Stack
// Good: Using bcrypt with proper cost
// Current - returns everything
res.json({ ...doc.toObject(), id: doc._id.toString() });
// Define safe fields to return
const safeUserFields = {
// Exclude: passwordHash, resetToken, resetTokenExpiresAt
const user = await User.findById(id).select(safeUserFields);
// server.js security setup
import helmet from 'helmet';
// CORS - strict origin
origin: process.env.FRONTEND_ORIGIN,  // No fallback to *
// Body parsing with limits
app.use(express.json({ limit: '10kb' }));
// NoSQL injection prevention
app.use(mongoSanitize());
const limiter = rateLimit({
app.use('/api/', limiter);
app.use((req, res, next) => {
console.log(`${new Date().toISOString()} ``{req.method} ``{req.path} - ${req.ip}`);
Apply auth middleware to all protected routes
Remove hardcoded JWT secret fallback
Require JWT_SECRET in environment
Add refresh token mechanism
Implement token revocation
Add organization membership check
Implement role-based access control
Add resource ownership validation
Create permission matrix documentation
Add Zod schemas for all endpoints
Install and configure mongo-sanitize
Add request body size limits
Validate file uploads (if any)
Fix password reset token exposure
Use cryptographic random for tokens
Hash tokens before storage
Add password complexity requirements
Implement account lockout
Add rate limit to auth endpoints (strict)
Add rate limit to API endpoints (general)
Add rate limit to password reset
Consider Redis for distributed rate limiting
Logging & Monitoring
Log all authentication attempts
Log authorization failures
Log sensitive data access
Set up security alerts
Add Helmet middleware
Configure strict CSP
Set secure cookie flags
Implementation Priority
1. Apply auth middleware to all routes
2. Remove JWT secret fallback
3. Fix password reset token exposure
4. Add basic rate limiting
1. Add input validation (Zod)
2. Add mongo-sanitize
3. Implement organization-level authorization
4. Add role-based restrictions
1. Add security logging
3. Set up monitoring alerts
Regular dependency updates
Incident response planning
Frontend Layer Analysis
Technology Version Purpose
React 19.x UI framework
TypeScript 5.x Type safety
Tailwind CSS 4.x Styling
Google GenAI latest AI features
1. TypeScript Type Safety
Comprehensive type definitions in types.ts:
!"" App.tsx              # Main router & state management
!"" types.ts             # Centralized type definitions
!"" index.tsx            # React entry point
!"" index.css            # Global styles
!"" views/               # Page-level components (17 views)
#   !"" SplashView.tsx
#   !"" LoginView.tsx
#   !"" RegistrationView.tsx
#   !"" DashboardView.tsx
#   !"" HelpFormView.tsx
#   !"" OrgDashboardView.tsx
#   !"" SettingsView.tsx
#   !"" AlertsView.tsx
#   !"" AssessmentView.tsx
#   !"" PopulationView.tsx
#   !"" RecoveryView.tsx
#   !"" DroneView.tsx
#   !"" LogisticsView.tsx
#   !"" PresentationView.tsx
#   $"" OrgRegistrationView.tsx
!"" components/          # Reusable UI components
#   !"" Ticker.tsx       # Broadcast message bar
#   !"" BottomNav.tsx    # Navigation
$"" services/            # Business logic
!"" storage.ts       # LocalStorage + API orchestration
!"" api.ts           # REST client
!"" translations.ts  # i18n
!"" mockGenAI.ts     # AI mock for development
$"" validation.ts    # Form validation
// Strong enum types
export type EmergencyType =
| 'Medical' | 'Fire' | 'Flood' | 'Structure Damage' | 'Other';
// Well-defined interfaces
2. View State Management
Clean navigation pattern:
3. Offline-First Architecture
4. Internationalization
| 'SPLASH' | 'LOGIN' | 'REGISTRATION' | 'DASHBOARD'
| 'HELP_WIZARD' | 'ORG_DASHBOARD' | 'SETTINGS' | 'MAP'
| 'RECOVERY' | 'DRONE' | 'LOGISTICS' | 'PRESENTATION'
| 'ORG_REGISTRATION';
// Navigation is type-safe
setCurrentView('DASHBOARD');  // ✓ Valid
setCurrentView('INVALID');    // ✗ Type error
// LocalStorage as primary store
// Sync flag pattern
async submitHelpRequest(data: HelpRequestData) {
const record = { ...data, synced: navigator.onLine };
this.saveLocally(record);
await this.syncToServer(record);
record.synced = true;
// services/translations.ts
const translations: Record<LanguageCode, Record<string, string>> = {
'app.title': 'AERA Emergency Response',
'button.submit': 'Submit',
'app.title': 'AERA Respuesta de Emergencia',
'button.submit': 'Enviar',
5. Event-Driven Updates
Issues & Improvements
1. State Management Complexity
Problem: All state in App.tsx via useState
Props drilling through multiple levels
Hard to track state changes
Re-renders cascade unnecessarily
Recommendation: Consider Zustand or Jotai for state management:
2. Large Component Files
Problem: Some views are very large (800+ lines):
Recommendation: Extract into smaller components:
return translations[currentLanguage]?.[key] || translations['en'][key] || key;
// Listening for updates
const handler = () => refreshData();
// App.tsx has 20+ useState calls
const [userProfile, setUserProfile] = useState<UserProfile | null>(null);
const [orgProfile, setOrgProfile] = useState<OrganizationProfile | null>(null);
const [helpRequest, setHelpRequest] = useState<HelpRequestRecord | null>(null);
const [language, setLanguage] = useState<LanguageCode>('en');
// stores/appStore.ts
import { create } from 'zustand';
interface AppState {
userProfile: UserProfile | null;
orgProfile: OrganizationProfile | null;
setUser: (user: UserProfile | null) => void;
export const useAppStore = create<AppState>((set) => ({
currentView: 'SPLASH',
setView: (view) => set({ currentView: view }),
setUser: (user) => set({ userProfile: user }),
// Usage in components
const { currentView, setView } = useAppStore();
storage.ts     - 1043 lines
HelpFormView   - ~600 lines
OrgDashboard   - ~500 lines
3. Type Mismatches with Backend
Problem: Frontend types don't match backend schemas:
1. Generate types from backend schemas
2. Or maintain shared type package
3. Add runtime validation
4. Console.log Statements
Problem: Debug logging left in production code:
Recommendation: Use proper logging:
// Before: HelpFormView.tsx (600 lines)
const HelpFormView = () => {
// All 5 steps inline
// After: Split into step components
!"" HelpFormView.tsx       # Container (100 lines)
!"" SafetyStep.tsx         # Step 1
!"" SituationStep.tsx      # Step 2
!"" ResourcesStep.tsx      # Step 3
!"" VulnerabilityStep.tsx  # Step 4
!"" ConfirmationStep.tsx   # Step 5
$"" useHelpForm.ts         # Custom hook for form logic
// Frontend (types.ts)
status: 'PENDING' | 'APPROVED' | 'FULFILLED' | 'STOCKED';  // Has APPROVED
// Backend (models/request.js)
status: { enum: ['PENDING', 'FULFILLED', 'STOCKED'] },  // Missing APPROVED!
// Missing: signature, signedAt, receivedSignature
// Shared validation schema
export const ReplenishmentRequestSchema = z.object({
quantity: z.number().positive(),
status: z.enum(['PENDING', 'APPROVED', 'FULFILLED', 'STOCKED']),
export type ReplenishmentRequest = z.infer<typeof ReplenishmentRequestSchema>;
console.log('Found user profile:', user);
const isDev = import.meta.env.DEV;
5. Error Handling in API Calls
Problem: Inconsistent error handling:
Recommendation: Centralized API client:
export const logger = {
debug: (...args: any[]) => isDev && console.log('[DEBUG]', ...args),
info: (...args: any[]) => console.log('[INFO]', ...args),
warn: (...args: any[]) => console.warn('[WARN]', ...args),
error: (...args: any[]) => console.error('[ERROR]', ...args),
logger.debug('API Base URL:', API_BASE);  // Only in dev
// services/api.ts - Some have try/catch
export async function loginAuth(payload) {
const res = await fetch(url, {...});
throw new Error(errorData.error || 'Failed');
console.error('Login error:', err);
export async function getInventory(orgId: string) {
const res = await fetch(`${API_BASE}/api/orgs/${orgId}/inventory`);
if (!res.ok) throw new Error('Failed to load inventory');  // Generic error
// services/apiClient.ts
private baseUrl: string;
constructor(baseUrl: string) {
this.baseUrl = baseUrl;
private async request<T>(
options?: RequestInit
const url = `${this.baseUrl}${path}`;
'Content-Type': 'application/json',
...this.getAuthHeader(),
...options?.headers,
const error = await res.json().catch(() => ({}));
throw new ApiError(res.status, error.message || 'Request failed', error);
if (err instanceof ApiError) throw err;
throw new ApiError(0, 'Network error', { original: err });
get<T>(path: string) { return this.request<T>(path); }
post<T>(path: string, data: any) {
6. Missing Loading & Error States
Problem: Some views don't handle loading/error:
Problem: Validation scattered across components:
Recommendation: Use React Hook Form + Zod:
return this.request<T>(path, { method: 'POST', body: JSON.stringify(data) });
export const api = new ApiClient(import.meta.env.VITE_API_URL);
const [data, setData] = useState(null);
fetchData().then(setData);  // No loading state, no error handling
return data ? <Content data={data} /> : null;  // Blank while loading
function useAsync<T>(asyncFn: () => Promise<T>, deps: any[] = []) {
const [state, setState] = useState<{
error: Error | null;
}>({ data: null, loading: true, error: null });
setState(s => ({ ...s, loading: true, error: null }));
.then(data => setState({ data, loading: false, error: null }))
.catch(error => setState({ data: null, loading: false, error }));
const { data, loading, error } = useAsync(() => api.get('/inventory'), [orgId]);
if (loading) return <Spinner />;
if (error) return <ErrorMessage error={error} />;
return <Content data={data} />;
const handleSubmit = () => {
if (!formData.name) {
setError('Name required');
if (!formData.email && !formData.phone) {
setError('Email or phone required');
// ... more inline validation
import { useForm } from 'react-hook-form';
import { zodResolver } from '@hookform/resolvers/zod';
const schema = z.object({
name: z.string().min(1, 'Name required'),
Component Quality Checklist
Views to Refactor (Priority Order)
View Lines Issues Priority
storage.ts (service)1043 Too large, mixed concernsP1
HelpFormView ~600 Monolithic, hard to test P1
OrgDashboardView~500 Too many responsibilities P2
LogisticsView ~400 Complex state managementP2
DashboardView ~300 Could be cleaner P3
Recommended File Structure
}).refine(d => d.email || d.phone, {
message: 'Email or phone required',
const MemberForm = () => {
const { register, handleSubmit, formState: { errors } } = useForm({
resolver: zodResolver(schema),
<form onSubmit={handleSubmit(onSubmit)}>
<input {...register('name')} />
{errors.name && <span>{errors.name.message}</span>}
#   #   !"" LoginView.tsx
#   #   !"" RegistrationView.tsx
#   #   $"" useAuth.ts
#   !"" help-request/
#   #   !"" HelpFormView.tsx
#   #   #   !"" SafetyStep.tsx
#   #   $"" useHelpRequest.ts
#   !"" organization/
#   #   !"" OrgDashboardView.tsx
#   #   !"" components/
#   #   $"" useOrganization.ts
#   #   !"" Button.tsx
#   #   !"" Input.tsx
#   #   !"" useAsync.ts
#   #   $"" useLocalStorage.ts
#       !"" logger.ts
#       $"" validation.ts
Performance Recommendations
1. Code Splitting: Lazy load views
2. Memoization: Prevent unnecessary re-renders
3. Virtual Lists: For large member lists
4. Image Optimization: Lazy load images, use WebP
5. Bundle Analysis: Check for large dependencies
#   #   !"" client.ts
#   #   $"" endpoints.ts
#       !"" localStorage.ts
const HelpFormView = lazy(() => import('./views/HelpFormView'));1
const MemberList = memo(({ members }) => {...});1
import { FixedSizeList } from 'react-window';1
npx vite-bundle-visualizer1
Prioritized Action Plan
This document provides a week-by-week implementation plan to address all identified issues, ordered by criticality and dependencies.
Phase 1: Critical Security Fixes (Week 1)
Day 1-2: Authentication Enforcement
Task 1.1: Apply Auth Middleware
Task 1.2: Remove JWT Secret Fallback
Day 2-3: Fix Password Reset
Task 1.3: Secure Reset Token Flow
// server.js - BEFORE
app.get('/api/orgs/:orgId/inventory', async (req, res) => {...});
// server.js - AFTER
// Create protected router
protectedRoutes.use(auth);
// Move all protected endpoints
protectedRoutes.post('/orgs/:orgId/inventory', async (req, res) => {...});
protectedRoutes.get('/orgs/:orgId/members', async (req, res) => {...});
// ... all other org routes
// Public routes stay on app
app.post('/api/auth/register', async (req, res) => {...});
app.post('/api/auth/login', async (req, res) => {...});
app.post('/api/auth/forgot', async (req, res) => {...});
app.post('/api/auth/reset', async (req, res) => {...});
app.get('/api/health', (req, res) => res.json({ ok: true }));
// Mount protected routes
console.error('FATAL: JWT_SECRET environment variable is required');
console.error('Generate one with: node -e "console.log(require(\'crypto\').randomBytes(64).toString(\'hex\'))"');
console.error('FATAL: JWT_SECRET must be at least 32 characters');
if (!email) return res.status(400).json({ error: 'email required' });
// Always same response (don't leak user existence)
const genericResponse = { ok: true, message: 'If account exists, reset instructions sent' };
if (!user) return res.json(genericResponse);
// Generate cryptographically secure token
Day 3-4: Input Validation
Task 1.4: Install Dependencies
Task 1.5: Add Validation Schemas
const rawToken = crypto.randomBytes(32).toString('hex');
// Store hash of token (so DB breach doesn't expose tokens)
const hashedToken = crypto
user.resetToken = hashedToken;
user.resetTokenExpiresAt = new Date(Date.now() + 15 * 60 * 1000); // 15 min
// TODO: Send email with rawToken (not returned in response!)
// In dev, log it for testing
console.log(`[DEV] Reset token for ``{email}: ``{rawToken}`);
res.json(genericResponse);
app.post('/api/auth/reset', async (req, res) => {
const { email, token, newPassword } = req.body || {};
if (!email || !token || !newPassword) {
return res.status(400).json({ error: 'email, token, and newPassword required' });
if (newPassword.length < 8) {
return res.status(400).json({ error: 'password must be at least 8 characters' });
// Hash the provided token to compare with stored hash
resetToken: hashedToken,
user.passwordHash = await bcrypt.hash(newPassword, 12);  // Increased from 10
user.resetToken = undefined;
npm install zod express-mongo-sanitize1
password: z.string().min(1, 'Password required'),
Task 1.6: Add Validation Middleware
Task 1.7: Apply to Routes
Day 4-5: Rate Limiting
Task 1.8: Install and Configure
fullName: z.string().min(1).max(100).optional(),
'FIRST_RESPONDER', 'GENERAL_USER', 'INSTITUTION_ADMIN']).default('GENERAL_USER'),
export const memberSchema = z.object({
name: z.string().min(1).max(100),
address: z.string().max(500).optional(),
status: z.enum(['SAFE', 'DANGER', 'UNKNOWN']).default('UNKNOWN'),
needs: z.array(z.string()).optional(),
export const inventorySchema = z.object({
water: z.number().int().min(0).default(0),
food: z.number().int().min(0).default(0),
blankets: z.number().int().min(0).default(0),
medicalKits: z.number().int().min(0).default(0),
export const requestSchema = z.object({
item: z.string().min(1),
quantity: z.number().int().positive(),
// middleware/validate.js
export const validate = (schema) => (req, res, next) => {
const result = schema.safeParse(req.body);
details: result.error.issues.map(i => ({
field: i.path.join('.'),
req.validatedBody = result.data;
import { loginSchema, registerSchema, memberSchema } from './validation/schemas.js';
// Global sanitization
// Apply validation to routes
app.post('/api/auth/login', validate(loginSchema), async (req, res) => {
const { email, phone, password } = req.validatedBody;
app.post('/api/auth/register', validate(registerSchema), async (req, res) => {
const { email, phone, password, fullName, role, orgId } = req.validatedBody;
protectedRoutes.post('/orgs/:orgId/members', validate(memberSchema), async (req, res) => {
const payload = req.validatedBody;
Phase 2: Organization Model (Week 2)
Day 1-2: Create Organization Model
Task 2.1: Create Schema
npm install express-rate-limit1
// Strict limit for auth
max: 5, // 5 attempts
message: { error: 'Too many attempts, please try again in 15 minutes' },
// Password reset limit (even stricter)
const resetLimiter = rateLimit({
windowMs: 60 * 60 * 1000, // 1 hour
max: 3, // 3 attempts per hour
message: { error: 'Too many reset attempts' },
windowMs: 60 * 1000, // 1 minute
max: 100, // 100 requests per minute
app.post('/api/auth/login', authLimiter, validate(loginSchema), ...);
app.post('/api/auth/register', authLimiter, validate(registerSchema), ...);
app.post('/api/auth/forgot', resetLimiter, ...);
app.use('/api', apiLimiter);
const organizationSchema = new mongoose.Schema(
name: { type: String, required: true, maxlength: 200 },
enum: ['CHURCH', 'NGO', 'COMMUNITY_CENTER', 'LOCAL_GOV'],
address: { type: String, maxlength: 500 },
adminContact: { type: String, maxlength: 100 },
adminEmail: { type: String },
replenishmentPhone: { type: String },
allowPublicMembership: { type: Boolean, default: false },
requireApproval: { type: Boolean, default: true },
organizationSchema.index({ name: 'text' });
organizationSchema.index({ type: 1 });
organizationSchema.index({ verified: 1, active: 1 });
export const Organization =
mongoose.models.Organization || mongoose.model('Organization', organizationSchema);
Task 2.2: Add API Routes
Day 3-4: Migration Script
Task 2.3: Migrate Frontend Data
mongoose.models.Organization || mongoose.model('Organization', organizationSchema);34
// routes/organizations.js
import { Organization } from '../models/organization.js';
import { auth, requireRole } from '../middleware/auth.js';
import { validate } from '../middleware/validate.js';
import { organizationSchema } from '../validation/schemas.js';
const router = express.Router();
// List organizations (public for discovery)
router.get('/', async (req, res) => {
const { type, verified } = req.query;
const filter = { active: true };
if (type) filter.type = type;
if (verified !== undefined) filter.verified = verified === 'true';
const orgs = await Organization.find(filter)
.select('name type address verified')
// Get single organization
router.get('/:id', async (req, res) => {
const org = await Organization.findById(req.params.id).lean();
// Create organization (requires login)
router.post('/', auth, validate(organizationSchema), async (req, res) => {
const org = await Organization.create(req.validatedBody);
res.status(201).json(org);
// Update organization (requires admin of that org)
router.put('/:id', auth, requireRole('ADMIN', 'INSTITUTION_ADMIN'), async (req, res) => {
// Check user belongs to org or is system admin
if (req.user.role !== 'ADMIN' && req.user.orgId !== req.params.id) {
return res.status(403).json({ error: 'Not authorized for this organization' });
const org = await Organization.findByIdAndUpdate(
export default router;
// scripts/migrate-organizations.js
// Seed data from frontend storage.ts
_id: new mongoose.Types.ObjectId(),
address: '456 Faith Avenue, Maplewood, FL 33025',
replenishmentProvider: 'Diocese of Miami',
replenishmentEmail: 'logistics@diocesemiami.org',
replenishmentPhone: '305-555-1000',
Day 5: Update Frontend
Task 2.4: Use API Instead of LocalStorage
Phase 3: Data Integrity (Week 3)
Consolidate Member Status
address: '789 Charity Lane, Fort Lauderdale, FL 33301',
adminPhone: '555-0110',
replenishmentEmail: 'supplies@fema.gov',
replenishmentPhone: '800-555-FEMA',
await mongoose.connect(process.env.MONGODB_URI, {
console.log('Connected to MongoDB');
for (const org of SEED_ORGS) {
const existing = await Organization.findOne({ name: org.name });
console.log(`Organization "${org.name}" already exists, skipping`);
await Organization.create(org);
console.log(`Created organization: ${org.name}`);
console.log('Migration complete');
migrate().catch(err => {
console.error('Migration failed:', err);
// services/api.ts - Add organization endpoints
export async function listOrganizations(params?: { type?: string; verified?: boolean }) {
const query = new URLSearchParams(params as any).toString();
const res = await fetch(`${API_BASE}/api/organizations${query ? '?' + query : ''}`);
if (!res.ok) throw new Error('Failed to load organizations');
export async function getOrganization(id: string) {
const res = await fetch(`${API_BASE}/api/organizations/${id}`);
if (!res.ok) throw new Error('Failed to load organization');
export async function createOrganization(payload: OrganizationProfile) {
const res = await fetch(`${API_BASE}/api/organizations`, {
headers: { 'Content-Type': 'application/json', ...getAuthHeader() },
if (!res.ok) throw new Error('Failed to create organization');
Task 3.1: Add statusUpdatedAt to Member
Task 3.2: Migrate MemberStatus to Member
Task 3.3: Update Routes
Phase 4: Quality & Testing (Week 4)
Task 4.1: Install Testing Dependencies
db.members.updateMany(
{ statusUpdatedAt: { $exists: false } },
{ $set: { statusUpdatedAt: new Date() } }
// scripts/consolidate-status.js
const statuses = await MemberStatus.find().lean();
await Member.updateOne(
{ _id: status.memberId, orgId: status.orgId },
status: status.status,
statusUpdatedAt: status.updatedAt
// After verification, drop collection
// db.memberstatuses.drop();
// Remove MemberStatus routes, use Member only
app.post('/api/orgs/:orgId/members/:id/status', auth, async (req, res) => {
const { status } = req.body;
const doc = await Member.findByIdAndUpdate(
{ $set: { status, statusUpdatedAt: new Date() } },
npm install -D vitest @testing-library/react @testing-library/jest-dom supertest1
// tests/api/auth.test.js
import { describe, it, expect, beforeAll, afterAll } from 'vitest';
import request from 'supertest';
import { app } from '../../server.js';
describe('Auth API', () => {
describe('POST /api/auth/register', () => {
it('should register new user with email', async () => {
const res = await request(app)
.post('/api/auth/register')
email: 'test@example.com',
password: 'securepassword123',
fullName: 'Test User',
expect(res.status).toBe(200);
expect(res.body).toHaveProperty('token');
expect(res.body.user.email).toBe('test@example.com');
Task 4.3: Request Logging
it('should reject registration without email or phone', async () => {
.send({ password: 'password123' });
expect(res.status).toBe(400);
it('should reject weak passwords', async () => {
email: 'weak@example.com',
describe('POST /api/auth/login', () => {
it('should login with valid credentials', async () => {
.post('/api/auth/login')
it('should reject invalid password', async () => {
password: 'wrongpassword',
expect(res.status).toBe(401);
npm install morgan winston1
import morgan from 'morgan';
level: process.env.LOG_LEVEL || 'info',
format: winston.format.combine(
winston.format.timestamp(),
new winston.transports.File({ filename: 'logs/error.log', level: 'error' }),
new winston.transports.File({ filename: 'logs/combined.log' }),
logger.add(new winston.transports.Console({
format: winston.format.simple(),
app.use(morgan('combined', {
stream: { write: (message) => logger.info(message.trim()) }
Week Focus Key Deliverables
1 Security Auth enforcement, input validation, rate limiting
2 Data Model Organization model, API routes, migration
3 Data Integrity Status consolidation, schema sync
4 Quality Test suite, logging, error handling
Performance optimization
Real-time features (WebSocket)
Monitoring & alerting
Gotchas and Hidden Risks
This document identifies non-obvious issues, edge cases, and potential problems that may not be immediately apparent from code review but could
cause significant issues in production.
1. LocalStorage Size Limits
localStorage limit is typically 5-10MB per origin
As organizations grow (1000+ members, 100s of help requests), data will exceed limit
localStorage.setItem() will silently fail or throw QuotaExceededError
All subsequent writes fail, corrupting app state
1. Implement data pruning (archive old records)
2. Split data across multiple keys
3. Use IndexedDB for larger storage
4. Rely on backend as source of truth
2. Race Condition in Sync
User submits request
Local save succeeds, server call in progress
User refreshes page or closes app before server response
// storage.ts stores everything in one localStorage key
localStorage.setItem(DB_KEY, JSON.stringify(db));
// This could happen
// Data not saved! User doesn't know
// storage.ts - submitHelpRequest
// Save locally first
db.helpRequests.push(record);
const remote = await createHelpRequest(userId, payload);
// Update local with server ID
record.id = remote.id;
this.saveDB(db);  // Second save
Local record has temporary ID, server has different ID
Data becomes inconsistent
3. JWT Expiry Without Refresh
No refresh token mechanism
After 7 days, user is logged out mid-session
If user is filling out help request form, they lose their work
API calls start failing silently
Implement token refresh
Or detect expiry and prompt re-login before critical actions
4. The "Empty String" Organization Problem
User could query /api/orgs/doesnt-exist/members
Returns empty array (not an error)
Frontend doesn't know if org doesn't exist or just has no members
T0: Submit request, local ID = "local-123"
T1: Server starts processing
T2: User closes browser
T3: Server creates record with ID = "abc456"
T4: User reopens - local has "local-123", server has "abc456"
T5: User submits update to "local-123" - 404 on server
const signToken = (user) =>
{ expiresIn: '7d' }  // 7 day expiry
Day 1: User logs in, gets token
Day 7, Hour 23: User starts filling 5-step help wizard
Day 8: User clicks submit
Result: 401 Unauthorized, form data lost
// server.js routes use orgId from URL
const orgId = req.params.orgId;  // Could be anything
const members = await api.getMembers('TYPO-1234');
// Returns [] - is org empty or doesn't exist?
if (members.length === 0) {
// Show "No members" or "Org not found"?
5. Status Enum Mismatch
Frontend sends status: 'APPROVED'
Mongoose validation fails
500 error or silent rejection
User doesn't know why action failed
Edge Cases to Check:
ReplenishmentRequest.status - Frontend has APPROVED, backend doesn't
HelpRequest.status - Need to verify match
6. The Infinite Inventory Problem
No validation of deliveredQuantity
Could be negative (subtract from inventory)
Could be absurdly large (integer overflow)
No maximum inventory limits
7. Member Deletion Doesn't Cascade
MemberStatus records remain orphaned
HelpRequests referencing member remain
status: { enum: ['PENDING', 'FULFILLED', 'STOCKED'] }  // No APPROVED!
// server.js - When request is STOCKED, add to inventory
if (status === 'STOCKED' && deliveredQuantity > 0) {
{ $inc: inc },  // Always adds
curl -X POST /api/requests/123/status \
-d '{"status":"STOCKED","deliveredQuantity":-1000}'
# Inventory goes negative!
-d '{"status":"STOCKED","deliveredQuantity":999999999999}'
# Inventory explodes
No cleanup of related data
8. Timezone Handling
String timestamps aren't timezone-aware
Server time vs client time differences
"Yesterday" could be different for different users
Sorting by string dates fails
9. The "Demo Mode" Security Hole
Seed users in localStorage can be logged into without password
Anyone who knows seed user emails can access their accounts
"local-demo-token" accepted somewhere?
10. Concurrent Inventory Updates
members:        [deleted]
memberstatuses: { memberId: "deleted-id" }  // Still exists
helprequests:   { userId: "deleted-id" }    // Still exists
// Various places store timestamps as strings
timestamps: true  // Mongoose adds createdAt/updatedAt as Date
// Frontend formats dates
new Date(timestamp).toLocaleDateString()
Server (UTC): 2025-01-31T23:30:00Z
User (EST):   2025-01-31T18:30:00 "today"
User (PST):   2025-01-31T15:30:00 "today"
User (Tokyo): 2025-02-01T08:30:00 "tomorrow"
// storage.ts - loginWithCredentials
// Bypass password check for demo users!
return { token: 'local-demo-token', user };
// ... fall through to real auth
// Two requests update inventory simultaneously
// Request A: water = 100, add 50
// Request B: water = 100, subtract 20
// Without transactions:
Multiple admins updating inventory
Replenishment stocking + manual adjustment
Medium-Impact Gotchas
11. Help Request Priority Not Recalculated
Once submitted, priority is fixed. If data changes, priority doesn't update.
All deletes are hard deletes. No recovery possible.
13. Broadcast History Lost
Only current broadcast stored. Previous messages gone.
Users can't export their data. GDPR/privacy concerns.
15. Session Not Invalidated on Password Change
Old JWTs remain valid after password reset.
16. Console Logging Sensitive Data
17. Error Messages Leak Implementation
18. No Request Timeout
API calls could hang indefinitely.
19. Case-Sensitive Email
User@Example.com and user@example.com treated as different.
20. Empty Array vs Null Inconsistency
// B writes: 80  // Overwrites A's change!
// Result: 80 (should be 130)
// Use $inc for atomic operations
{ $inc: { water: 50 } }  // Atomic increment
console.log('Found user profile:', user);  // Includes sensitive data
res.status(500).json({ error: err.message });
// Could expose: "Cannot read property 'x' of undefined"
Checklist for Testing
Test with 1000+ members in an organization
Test with localStorage near quota
Test concurrent admin updates
Test JWT expiry during form submission
Test all enum values match frontend/backend
Test negative quantity submissions
Test deletion cascade behavior
Test timezone edge cases (midnight boundary)
Verify demo mode is disabled in production
100 concurrent help request submissions
50 concurrent inventory updates
1000 members status check query
Rate limit effectiveness
Attempt to access other org's data
JWT forgery attempts
Rate limit bypass attempts
Gotcha Likelihood Impact Priority
LocalStorage limit Medium High P1
Sync race condition High Medium P1
JWT expiry no refreshHigh Medium P1
Enum mismatch High Medium P1
Inventory validation Medium High P1
Orphaned data Medium Medium P2
Timezone issues High Low P2
Demo mode security Low High P2
Concurrent updates Medium Medium P2
No soft delete Low Medium P3
// Some endpoints return [] for empty
res.json(docs);  // []
// Others return null
res.json(null);  // null
// Frontend has to handle both
User Authentication Flow
!"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""#
$                              AERA ARCHITECTURE                               $
%"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""&
$                                                                             $
$  !"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""#   $
$  $                           CLIENTS                                    $   $
$  $  !""""""""""""""#  !""""""""""""""#  !""""""""""""""#              $   $
$  $  $   Mobile     $  $   Desktop    $  $    Tablet    $              $   $
$  $  $   (PWA)      $  $   Browser    $  $   Browser    $              $   $
$  $  '""""""(""""""")  '""""""(""""""")  '""""""(""""""")              $   $
$  $         $                 $                  $                      $   $
$  $         '""""""""""""""""*"""""""""""""""""")                      $   $
$  $                          $                                          $   $
$  '""""""""""""""""""""""""""*"""""""""""""""""""""""""""""""""""""""""")   $
$                             $                                               $
$                             ▼                                               $
$  $                      FRONTEND (Netlify)                              $   $
$  $  !"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""#   $   $
$  $  $                    React 19 + TypeScript                     $   $   $
$  $  $  !"""""""""""""#  !"""""""""""""#  !"""""""""""""#         $   $   $
$  $  $  $    Views    $  $  Services   $  $ Components  $         $   $   $
$  $  $  $  (17 pages) $  $  (storage,  $  $  (Ticker,   $         $   $   $
$  $  $  $             $  $   api, i18n)$  $   NavBar)   $         $   $   $
$  $  $  '""""""""""""")  '""""""""""""")  '""""""""""""")         $   $   $
$  $  '""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""")   $   $
$  $              !"""""""""""*"""""""""""#                             $   $
$  $              ▼           ▼           ▼                             $   $
$  $  !""""""""""""""# !""""""""""# !"""""""""""#                      $   $
$  $  $ LocalStorage $ $ REST API $ $ Gemini AI $                      $   $
$  $  $  (Offline)   $ $ (Online) $ $  (GenAI)  $                      $   $
$  $  '"""""""""""""") '""""(""""") '""""""""""")                      $   $
$  '""""""""""""""""""""""""*"""""""""""""""""""""""""""""""""""""""""""")   $
$                           $                                                 $
$                           $ HTTPS                                           $
$                           ▼                                                 $
$  $                       BACKEND (Render)                               $   $
$  $  $                    Express.js + Node.js                      $   $   $
$  $  $  $   Routes    $  $ Middleware  $  $   Models    $         $   $   $
$  $  $  $  (auth,     $  $  (auth,     $  $ (Mongoose)  $         $   $   $
$  $  $  $   orgs)     $  $   cors)     $  $             $         $   $   $
$  $                     DATABASE (MongoDB Atlas)                         $   $
$  $  !"""""""""# !"""""""""# !"""""""""# !"""""""""# !"""""""""#       $   $
$  $  $  users  $ $ members $ $inventory$ $requests $ $  help   $       $   $
$  $  $         $ $         $ $         $ $         $ $requests $       $   $
$  $  '""""""""") '""""""""") '""""""""") '""""""""") '""""""""")       $   $
$  $  !"""""""""# !"""""""""#                                            $   $
$  $  $ member  $ $broadcast$
organizations (MISSING!)               $   $
$  $  $ status  $ $         $                                            $   $
$  $  '""""""""") '""""""""")                                            $   $
$  '""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""")   $
'""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""")
Help Request Submission Flow
Inventory Replenishment Flow
!""""""""""#     !""""""""""#     !""""""""""#     !""""""""""#
$  Client  $     $ Frontend $     $ Backend  $     $ Database $
'""""(""""")     '""""(""""")     '""""(""""")     '""""(""""")
$                $                $                $
$ Enter creds    $                $                $
$""""""""""""""">$                $                $
$                $ POST /auth/login               $
$                $""""""""""""""">$                $
$                $                $ Find user      $
$                $                $""""""""""""""">$
$                $                $ User doc       $
$                $                $<"""""""""""""""$
$                $                $ Verify bcrypt  $
$                $                $ Sign JWT       $
$                $ { token, user }$                $
$                $<"""""""""""""""$                $
$                $ Store token    $                $
$                $ localStorage   $                $
$ Navigate to    $                $                $
$ Dashboard      $                $                $
$<"""""""""""""""$                $                $
$ Complete wizard$                $                $
$                $ Calculate      $                $
$                $ priority       $                $
$                $ Save to        $                $
$                $ (synced=false) $                $
$                $ POST /users/:id/help           $
$                $                $ Create doc     $
$                $                $ { _id, ... }   $
$                $ { id, timestamp }              $
$                $ Update local   $                $
$                $ with server ID $                $
$                $ (synced=true)  $                $
$ Show confirm   $                $                $
!""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""#
$                    REPLENISHMENT LIFECYCLE                            $
%""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""&
$                                                                       $
$  !"""""""""#      !"""""""""#      !"""""""""#      !"""""""""#     $
$  $ PENDING $ """> $APPROVED $ """> $FULFILLED$ """> $ STOCKED $     $
$  '""""""""")      '""""""""")      '""""""""")      '""""""""")     $
$       $                $                $                $           $
$       ▼                ▼                ▼                ▼           $
$  !"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""#    $
$  $                      ACTIONS                                 $    $
$  %"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""&    $
$  $ Org Admin     Provider      Provider       Org Admin        $    $
$  $ creates       approves &    releases &     receives &       $    $
$  $ request       assigns       signs off      confirms stock   $    $
$  '""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""")    $
$                                                     $                $
$                                                     ▼                $
$                                          !"""""""""""""""""#        $
$                                          $ AUTO-INCREMENT  $        $
$                                          $   INVENTORY     $        $
$                                          $ water += qty    $        $
$                                          $ food += qty     $        $
$                                          $ etc.            $        $
$                                          '""""""""""""""""")        $
ISSUE: Backend missing APPROVED status!                         $
'"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""")
$                        DATABASE ENTITY RELATIONSHIPS                         $
$                                                                              $
$  !"""""""""""""""""#                    !"""""""""""""""""#                 $
$  $  Organization   $                    $      User       $                 $
MISSING!    $◄"""""""""""""""""""$                 $                 $
$  %"""""""""""""""""&   user.orgId       %"""""""""""""""""&                 $
$  $ _id             $                    $ _id             $                 $
$  $ name            $                    $ email           $                 $
$  $ type            $                    $ phone           $                 $
$  $ address         $                    $ passwordHash    $                 $
$  $ verified        $                    $ role            $                 $
$  '""""""""("""""""")                    $ orgId """"""""""*"► (soft FK)     $
$           $                             $ fullName        $                 $
$           $                             '""""""""("""""""")                 $
$           $                                      $                          $
$           $ orgId                                $ userId                   $
$           ▼                                      ▼                          $
$  $     Member      $                    $   HelpRequest   $                 $
$  %"""""""""""""""""&                    %"""""""""""""""""&                 $
$  $ orgId """"""""""*"► (soft FK)        $ orgId """"""""""*"► (soft FK)     $
$  $ name            $                    $ userId """""""""*"► (soft FK)     $
$  $ status          $◄"""#               $ data {}         $                 $
$  $ phone           $    $               $ status          $                 $
$  $ needs[]         $    $               $ priority        $                 $
$  '""""""""""""""""")    $               $ location        $                 $
$                         $               '""""""""""""""""")                 $
$                         $ DUPLICATE!                                        $
$  !"""""""""""""""""#    $                                                   $
$  $  MemberStatus   $"""")                                                   $
$  %"""""""""""""""""&                                                        $
$  $ orgId           $                    !"""""""""""""""""#                 $
$  $ memberId        $                    $    Inventory    $                 $
$  $ status          $◄"" same data!      %"""""""""""""""""&                 $
$  '""""""""""""""""")                    $ orgId """"""""""*"► 1:1 per org   $
$                                         $ water           $                 $
$                                         $ food            $                 $
$  !"""""""""""""""""#                    $ blankets        $                 $
$  $    Request      $                    $ medicalKits     $                 $
$  %"""""""""""""""""&                    '""""""""""""""""")                 $
$  $ _id             $                                                        $
$  $ orgId """"""""""*"► (soft FK)        !"""""""""""""""""#                 $
$  $ item            $                    $    Broadcast    $                 $
$  $ quantity        $                    %"""""""""""""""""&                 $
$  $ status          $                    $ orgId """"""""""*"► 1:1 per org   $
$  $ provider        $                    $ message         $                 $
$  '""""""""""""""""")                    '""""""""""""""""")                 $
All FK references are soft (string) - no validation!                   $
Deployment Architecture
$                         VIEW NAVIGATION FLOW                                 $
$                              !"""""""""#                                    $
$                              $ SPLASH  $ (entry point)                      $
$                              '""""("""")                                    $
$                                   $                                          $
$                        !""""""""""*""""""""""#                              $
$                        ▼          ▼          ▼                              $
$                   !""""""""# !""""""""# !""""""""""""#                      $
$                   $ LOGIN  $ $REGISTER$ $ORG_REGISTER$                      $
$                   '"""("""") '"""("""") '"""""("""""")                      $
$                       $          $            $                              $
$                       '""""""""""*"""""""""""")                              $
$                                  $                                           $
$                    !"""""""""""""*"""""""""""""#                            $
$                    ▼                           ▼                            $
$              !"""""""""""#              !""""""""""""""#                    $
$              $ DASHBOARD $              $ORG_DASHBOARD $                    $
$              $  (user)   $              $   (admin)    $                    $
$              '"""""(""""")              '""""""(""""""")                    $
$                    $                           $                            $
$       !""""""""""""*""""""""""""#              $                            $
$       ▼            ▼            ▼              ▼                            $
$  !"""""""""# !"""""""""# !"""""""""#    !""""""""""#                       $
$  $HELP_FORM$ $   MAP   $ $ ALERTS  $    $LOGISTICS $                       $
$  $(wizard) $ $(search) $ $ (Q&A)   $    $(inventory$                       $
$  '""""""""") '""""""""") '""""""""")    $ requests)$                       $
$                                          '"""""""""")                       $
$       $            $            $              $                            $
$  $   GAP   $ $ASSESSMNT$ $RECOVERY $    $POPULATION$                       $
$  $(finance)$ $(damage) $ $         $    $ (members)$                       $
$  '""""""""") '""""""""") '""""""""")    '"""""""""")                       $
$                                               $                             $
$                                               ▼                             $
$                                         !""""""""""#                        $
$                                         $  DRONE   $                        $
$                                         $(dispatch)$                        $
$                                         '"""""""""")                        $
$  All views can access:                                                       $
$  !"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""#        $
$  $  SETTINGS  $  PRESENTATION  $  (via bottom nav or header)       $        $
$  '""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""")        $
$                        DEPLOYMENT ARCHITECTURE                               $
$                           !"""""""""""""""""#                               $
$                           $    GitHub        $                               $
$                           $   Repository     $                               $
$                           '""""""""("""""""")                               $
$                                    $                                         $
$                           push to main                                       $
$                                    ▼                                         $
$                           $ GitHub Actions  $                               $
$                           $   CI/CD         $                               $
$                    !"""""""""""""""+"""""""""""""""#                        $
$                    $                               $                         $
Technology Decision Map
$                    ▼                               ▼                         $
$           !"""""""""""""""""#            !"""""""""""""""""#                $
$           $    Netlify      $            $     Render      $                $
$           $   (Frontend)    $            $    (Backend)    $                $
$           %"""""""""""""""""&            %"""""""""""""""""&                $
$           $ • Static build  $            $ • Node.js       $                $
$           $ • CDN delivery  $            $ • Express.js    $                $
$           $ • Auto HTTPS    $            $ • Auto-deploy   $                $
$           $ • Branch preview$            $ • Env vars      $                $
$           '""""""""("""""""")            '""""""""("""""""")                $
$                    $                              $                          $
$                    $    !"""""""""""""""""""""""""*"""""""#                 $
$                    $    $                         $       $                  $
$                    $    ▼                         ▼       ▼                  $
$                    $  HTTPS                     HTTPS   TCP/27017           $
$                    $    $            !""""""""""""+"""""""+""""""#          $
$                    $    $            $      MongoDB Atlas        $          $
$                    $    $            $      (Cloud Database)     $          $
$                    $    $            %"""""""""""""""""""""""""""&          $
$                    $    $            $ • Managed cluster         $          $
$                    $    $            $ • Auto backups            $          $
$                    $    $            $ • Connection pooling      $          $
$                    $    $            '""""""""""""""""""""""""""")          $
$                    $    $                                                    $
$           !""""""""+""""+""""""""#                                          $
$           $   Google Cloud       $                                          $
$           $   (Gemini API)       $                                          $
$           '"""""""""""""""""""""")                                          $
$  Environment Variables:                                                      $
$  $ Frontend (Netlify):         $ Backend (Render):                      $   $
$  $ • VITE_API_URL              $ • MONGODB_URI                          $   $
$  $ • VITE_GEMINI_API_KEY       $ • MONGODB_DB                           $   $
$  $                             $ • JWT_SECRET                           $   $
$  $                             $ • FRONTEND_ORIGIN                      $   $
$  $                             $ • PORT                                 $   $
$                         TECHNOLOGY DECISIONS                                 $
$  CHOSEN                           $  ALTERNATIVES CONSIDERED                 $
$  """""""""""""""""""""""""""""""""*""""""""""""""""""""""""""""""""""""""   $
$  Frontend:                        $                                          $
$  ✓ React 19                       $  Next.js, Vue, Svelte                   $
$  ✓ TypeScript                     $  JavaScript                              $
$  ✓ Vite                           $  Create React App, Webpack              $
$  ✓ Tailwind CSS                   $  Styled Components, CSS Modules         $
$  Backend:                         $                                          $
$  ✓ Express.js                     $  Fastify, Hono, NestJS                  $
$  ✓ Mongoose ODM                   $  Prisma, Raw MongoDB driver             $
$  ✓ JWT + bcrypt                   $  Passport.js, Auth0, Firebase Auth      $
$  Database:                        $                                          $
$  ✓ MongoDB Atlas                  $  PostgreSQL, Firebase, Supabase         $
$  Hosting:                         $                                          $
$  ✓ Netlify (frontend)             $  Supabase, Cloudflare Pages             $
$  ✓ Render (backend)               $  Railway, Fly.io, AWS                   $
$  AI:                              $                                          $
$  ✓ Google Gemini                  $  OpenAI GPT-4, Claude, Llama            $
Decision Record: Supabase Migration
Decision: Migrate AERA from Express.js + MongoDB to Supabase + PostgreSQL
Date: January 31, 2026
This document records the decision to migrate AERA's backend infrastructure to Supabase. This is a strategic choice based on security requirements,
development velocity, operational costs, and the specific needs of emergency response applications.
Express.js (custom backend)
MongoDB Atlas (document database)
Custom JWT authentication
No real-time capability
Supabase (Backend-as-a-Service)
PostgreSQL (relational database)
Supabase Auth (managed authentication)
Supabase Realtime (WebSocket subscriptions)
1. Security: Supabase Wins
Security Feature Current Stack Supabase
Authentication Defined but not applied to routes Enforced by default
Authorization None (any user can access any data)Row Level Security at DB layer
Input Validation None PostgreSQL constraints + RLS policies
Secret ManagementHardcoded 'dev-secret' fallback Managed, rotatable
Password Reset Token exposed in API response Secure email flow
Rate Limiting None Built-in
Key Finding: The current Express.js stack has authentication middleware that was never applied. This is the #1 security vulnerability. Supabase makes
this impossible—RLS policies are enforced at the database level, not the application level.
Evidence: server.js lines 1-50 define authenticateToken middleware that is imported but never used on protected routes.
2. Real-Time: Critical for Emergency Response
Scenario Current (Polling) Supabase (WebSocket)
Member status change30-60 second delay <100ms
New help request Manual refresh requiredInstant notification
Inventory update Stale data possible Real-time sync
Broadcast message Polling interval Immediate delivery
Key Finding: Emergency response apps need sub-second updates. A 60-second polling delay during a crisis could cost lives. Supabase provides real-
time subscriptions out of the box.
Evidence: Current codebase has no WebSocket implementation. Adding real-time to Express requires 2-3 weeks of development (Socket.io or Pusher
3. Data Model Fit: PostgreSQL is Correct
AERA's data is fundamentally relational:
Users belong to Organizations
Members belong to Organizations
Help Requests are created by Users
Inventory belongs to Organizations
Data Requirement MongoDB PostgreSQL
Foreign key enforcement
Soft references only
Key Finding: The current MongoDB schema already has organizationId fields that aren't enforced—orphan records are possible. PostgreSQL with
foreign keys prevents this class of bug entirely.
Evidence: models/member.js has organizationId: { type: mongoose.Schema.Types.ObjectId, ref: 'Organization' } but the Organization model
doesn't exist in the backend.
4. Development Velocity: 10x Faster
Task Custom Express Supabase
CRUD API for new table2-4 hours 0 (auto-generated)
Add authentication 1-2 days 10 minutes (enable)
Add real-time 2-3 weeks 1 hour (subscribe)
Add file storage 1 week 30 minutes
Add row-level security1-2 weeks 1-2 hours (policies)
Key Finding: The security fixes needed for the current stack represent 4-6 weeks of development work. Supabase provides these features
5. Cost Analysis: 60% Savings
Component Current Stack Supabase Stack
Database $25-40/mo (MongoDB Atlas)$25/mo (included)
Backend hosting$20-30/mo (Render) $0 (Supabase handles)
Auth service $15-20/mo (or security risk)$0 (included)
Real-time $25-30/mo (Pusher) or none$0 (included)
Frontend $0 (Supabase free) $20/mo (Supabase Pro)
Total $85-102/mo ~$45/mo
Annual savings: ~$480-684/year
Plus avoided development costs:
Security fixes: ~ 150/hr × 24 hrs)
Real-time implementation: ~$7,000 (2 weeks)
Total avoided: ~$21,000
6. Maintenance Burden: Lower
Maintenance Task Current Stack Supabase
Security patches Your responsibility Managed
Database backupsConfigure yourself Automatic
Scaling Manual interventionAutomatic
SSL certificates Manage yourself Managed
Monitoring Set up yourself Dashboard included
Risks and Mitigations
Risk 1: Vendor Lock-in
Mitigation: Supabase is open-source. Self-hosting is possible if needed.
Mitigation: PostgreSQL is standard SQL—data is portable.
Assessment: Low risk. Benefits outweigh lock-in concerns.
Risk 2: Learning Curve
Mitigation: Supabase has excellent documentation.
Mitigation: PostgreSQL knowledge is transferable.
Assessment: 1-2 days for basic proficiency, 1 week for advanced features.
Risk 3: Migration Complexity
Mitigation: Hybrid approach—fix critical security first, migrate in parallel.
Mitigation: MongoDB → PostgreSQL migration is well-documented.
Assessment: Medium complexity, but bounded (5-7 weeks max).
Dimension MongoDB/ExpressSupabase/PostgreSQLWinner
Security (default) Opt-in (missed) Opt-out (enforced) Supabase
Real-time Not present Built-in Supabase
Data model fit Document (wrong)Relational (correct) Supabase
Development speedSlow (custom) Fast (generated) Supabase
Monthly cost $85-102 $45 Supabase
Maintenance High Low Supabase
Scaling Manual Automatic Supabase
Phase 1: Security Sprint (2-3 weeks)
Apply critical fixes to current stack so app can enter controlled beta:
1. Apply auth middleware to all protected routes
2. Move JWT secret to environment variables
3. Add input validation with Zod
4. Fix password reset token exposure
5. Add basic rate limiting
Phase 2: Supabase Setup (1 week)
2. Design PostgreSQL schema (see ideal-stack-analysis/04-recommended-architecture.md)
3. Implement Row Level Security policies
4. Set up Supabase Auth
Phase 3: Data Migration (2 weeks)
1. Write migration scripts (MongoDB → PostgreSQL)
2. Run parallel writes to both databases
3. Verify data integrity
4. Switch reads to Supabase
Phase 4: Frontend Integration (2 weeks)
1. Replace fetch calls with Supabase client
2. Add real-time subscriptions
3. Update auth flow to Supabase Auth
4. Add TanStack Query for caching
Phase 5: Cleanup (1 week)
1. Remove Express server
2. Remove MongoDB connection
3. Update deployment pipeline
Total: 8-9 weeks (overlaps with Phase 1 beta period)
The question is not "Is Supabase better than custom Express?"—the evidence clearly shows it is for this use case.
The real questions were:
1. Is the current stack fixable? Yes, with 4-6 weeks of security work.
2. Is migration worth the effort? Yes—it saves 500/year in operations, while providing better security and real-time
3. Is now the right time? Yes—the app needs significant security work regardless. Doing that work toward a better architecture is more valuable than
patching the current one.
01-requirements-analysis.md
02-database-comparison.md
03-backend-comparison.md
04-recommended-architecture.md
06-websockets-and-mobile.md
21kindevelopmentcostsand
AERA Emergency Response App Technical Assessment & Strategic Recommendations Executive Summary | January 2026
Bottom Line AERA is a promising MVP with solid frontend architecture but critical security gaps. We will migrate to Supabase + PostgreSQL—this decision is final based on clear evidence across security, cost, and capability dimensions.
✅ Strategic Decision: Migrate to Supabase Supabase wins on every evaluation dimension: security, real-time capability, development speed, monthly costs, and maintenance burden. This is not a tentative recommendation—the evidence is conclusive.
⚠ Critical Action Required Do not use this app for real emergencies until security fixes are applied. The current authentication system is defined but not enforced—any user can access any data.
Why Supabase: The Evidence We evaluated the current stack against Supabase across six dimensions. Supabase wins all six. Dimension Current (Express + MongoDB) Supabase + PostgreSQL Security Auth middleware exists but NOT APPLIED. Any user can access any data. Row Level Security enforced at database level. Cannot be bypassed. Real-Time None. 30-60 second polling delays. Critical gap for emergencies. Built-in WebSocket. Sub-100ms updates. Zero additional code. Data Model Document store for relational data. No foreign key enforcement. Proper relations, enforced constraints, PostGIS for geolocation. Dev Speed 4-6 weeks to fix security. 2-3 weeks to add real-time. Security and real-time included. Days, not weeks. Monthly Cost $85-102/month ~$45/month (55% savings) Maintenance You manage security patches, backups, scaling. Managed platform. Automatic backups, scaling, updates.  Decision Scorecard Evaluation Criteria Winner Security by default Supabase Real-time capability Supabase Data model fit Supabase Development velocity Supabase Operating cost Supabase Maintenance burden Supabase FINAL SCORE Supabase 6/6
Current State Assessment
✅ What Works Well (Keep) Component Assessment React 19 + Vite Modern, fast, well-structured. Keep this entirely. Tailwind CSS Clean responsive design. No changes needed. 17-View Architecture Well-organized component structure. Portable to Supabase. Multi-language (en/es/fr) Critical for emergency response. Already implemented. Google Gemini AI Good integration. Works with any backend.
" What Must Change (Replace) Component Problem Supabase Solution Express.js Backend Auth middleware defined but never applied to routes RLS policies MongoDB Document store for relational data; no FK enforcement PostgreSQL Custom JWT Auth Hardcoded secrets, no refresh tokens, reset token exposed Supabase Auth No Real-Time 60-second delays during emergencies could cost lives Supabase Realtime
Financial Analysis Monthly Operating Costs Component Current Stack Supabase Stack Database $25-40 (MongoDB Atlas) $25 (included) Backend Hosting $20-30 (Render) $0 (Supabase handles) Auth Service $15-20 (or security risk) $0 (included) Real-time Service $25-30 (Pusher) or none $0 (included) Frontend Hosting $0 (Supabase free) $20 (Supabase Pro) MONTHLY TOTAL $85-102 ~$45 ANNUAL TOTAL $1,020-1,224 ~$540  Development Cost Comparison Work Required Fix Current Supabase Security fixes (auth, validation, secrets) $14,000 $0 (built-in) Real-time implementation $7,000 $0 (built-in) Database migration N/A $5,000 Frontend integration $2,000 $4,000 TOTAL DEVELOPMENT $23,000 $9,000
# Financial Summary Development savings: $14,000 (Supabase vs fixing current) Annual operating savings: $480-684 2-year total savings: ~$15,000-15,400
Implementation Plan Hybrid approach: Fix critical security issues immediately for controlled beta, then migrate to Supabase in parallel. Phase Timeline Deliverables Phase 1 Weeks 1-3 Security fixes to current stack: Apply auth middleware, move secrets to env vars, add input validation. App safe for controlled beta. Phase 2 Weeks 2-3 Supabase setup: Create project, design PostgreSQL schema, implement Row Level Security policies, configure auth. Phase 3 Weeks 4-5 Data migration: Write migration scripts, run parallel writes, verify integrity, switch reads to Supabase. Phase 4 Weeks 6-7 Frontend integration: Replace API calls with Supabase client, add real-time subscriptions, update auth flow. Phase 5 Week 8 Cleanup: Remove Express server and MongoDB, update deployment pipeline, documentation.  Milestone Target App safe for controlled beta Week 3 Supabase migration complete Week 7 Production-ready with real-time Week 8
Mobile Deployment Strategy For emergency response apps, speed of deployment matters more than app store presence. Approach Timeline When to Use PWA (Recommended) 1-2 days Default choice. Works offline, no app store approval, instant updates. Capacitor Wrapper 1 week Only if native push notifications are absolutely required. React Native 2-3 months Only if scale exceeds 50k users and native performance is needed.
Risk Acknowledgments Risk Mitigation Vendor lock-in with Supabase Supabase is open-source. PostgreSQL is standard SQL. Data is portable. Learning curve Excellent documentation. PostgreSQL knowledge is transferable. 1-2 days to proficiency. Migration complexity Bounded scope: 5-7 weeks maximum. Well-documented MongoDB → PostgreSQL path.
Decision Migrate AERA to Supabase + PostgreSQL. This decision is based on conclusive evidence across security, capability, cost, and maintainability dimensions. The project is salvageable and valuable—the architecture change positions it for long-term success.
Immediate Next Steps 1. Confirm budget allocation for 8-week implementation 2. Begin Phase 1 security fixes (app cannot be used for real emergencies until complete) 3. Set up Supabase project and begin schema design in parallel 4. Identify controlled beta users for Week 3 launch
— Assessment prepared January 2026 Based on comprehensive code review of AERA repository
Project: AERA (Autonomous Emergency Response Application)
Review Date: January 31, 2026
Scope: Full-stack architecture, security, database, and frontend analysis
AERA is a mobile-first emergency response platform designed to help citizens report emergencies, organizations manage members and inventory, and
first responders coordinate relief efforts. The application demonstrates solid foundational architecture but has critical security gaps that must be
addressed before production deployment.
Strategic Decision: Migrate to Supabase
After comprehensive analysis, Supabase + PostgreSQL is the recommended architecture. This is not a tentative suggestion—the evidence clearly
supports this migration path.
Factor Current Stack (Express + MongoDB)Supabase + PostgreSQL
Auth exists but not applied
RLS enforced at DB level
None (critical for emergencies)
Monthly Cost $85-102/month $45/month
Dev Effort for Security4-6 weeks Already done
Document store for relational data
Proper relations + PostGIS
See 09-supabase-decision.md for complete evidence and rationale.
Well structured (keep)
Document Description
01-whats-going-right.md Strengths and good practices
02-whats-going-wrong.md Critical issues and problems
03-database-layer.md Database architecture deep-dive
04-security-layer.md Security audit and fixes
05-frontend-layer.md Frontend architecture review
06-detailed-next-steps.md Prioritized action plan
07-gotchas-and-risks.md Hidden issues and edge cases
08-architecture-diagrams.mdVisual system documentation
09-supabase-decision.mdDecision record: Why Supabase
ideal-stack-analysis/ Detailed stack comparison
Critical Findings Summary
Immediate Action Required
1. Authentication middleware defined but never applied - All API routes are publicly accessible
2. No Organization model in backend - Orgs exist only in frontend localStorage
3. Hardcoded JWT secret fallback - 'dev-secret' used if env var missing
4. No input validation - Direct user input to database operations
5. Password reset token exposed in API response - Account takeover risk
6. No rate limiting on auth endpoints
7. Duplicate status tracking (Member vs MemberStatus)
8. No pagination on list endpoints
9. Frontend-backend type mismatches
10. No test coverage
Recommended Path Forward
Option A: Fix Current Stack (Not Recommended)
Result: Functional but still carrying technical debt
Option B: Hybrid Approach (Recommended)
Phase 1 (2-3 weeks): Critical security fixes to current stack
Phase 2 (4-6 weeks): Migrate to Supabase while app is in controlled beta
Cost: 10,000 initial + migration costs
Result: Safe for beta immediately, modern architecture for production
Option C: Full Rebuild
Result: Clean architecture, but delays launch
Target (Supabase Migration)
Frontend                    Backend                     Infrastructure
!!!!!!!!!!!!!!!!!!!!!!!!   !!!!!!!!!!!!!!!!!!!!!!!!   !!!!!!!!!!!!!!!!!!!!!!!!
React 19                    Express.js                  MongoDB Atlas
TypeScript                  Mongoose 9.x                Netlify (frontend)
Vite                        JWT + bcrypt                Render (backend)
Tailwind CSS                Node.js                     GitHub Actions
Google GenAI (Gemini)
Quick Start for Reviewers
React 19 (keep)             Supabase                    Supabase (DB + Auth)
TypeScript (keep)           - Auto-generated APIs       Supabase (frontend)
Vite (keep)                 - Row Level Security        Edge Functions
Tailwind CSS (keep)         - Real-time subscriptions   GitHub Actions
TanStack Query (add)        Edge Functions (custom)
# Start frontend (port 5173)
# Start backend (port 4000)
# Required env vars for backend
JWT_SECRET=<secure-random-string>